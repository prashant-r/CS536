
 -------------What i sent was -----------------------
 57299
 -------------What i sent was -----------------------
        0

Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk
 -------------What i sent was -----------------------
       103 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task
 -------------What i sent was -----------------------
       11. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when struc
 -------------What i sent was -----------------------
       21trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increas
 -------------What i sent was -----------------------
       22es its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client th
 -------------What i sent was -----------------------
       32the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 
 -------------What i sent was -----------------------
       3360, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP conges
 -------------What i sent was -----------------------
       43f the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by lin
 -------------What i sent was -----------------------
       44king with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off
 -------------What i sent was -----------------------
       54ication design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two argu
 -------------What i sent was -----------------------
       55ments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant 
 -------------What i sent was -----------------------
        1router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacIP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spac
 -------------What i sent was -----------------------
        2ket-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with ing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with 
 -------------What i sent was -----------------------
        3IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP 
 -------------What i sent was -----------------------
        4 its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separateaddress the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate
 -------------What i sent was -----------------------
        5separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs t data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs t
 -------------What i sent was -----------------------
        6 needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative posito use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative posit
 -------------What i sent was -----------------------
        7ve positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the neg
 -------------What i sent was -----------------------
       16irmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to teouter(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to te
 -------------What i sent was -----------------------
       17ts to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spaar down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spa
 -------------What i sent was -----------------------
       18cket spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own cing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own 
 -------------What i sent was -----------------------
       19our own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing rfile transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing r
 -------------What i sent was -----------------------
       20enting reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabileliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabil
 -------------What i sent was -----------------------
       23not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's  to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's 
 -------------What i sent was -----------------------
       24ation's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kIP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the k
 -------------What i sent was -----------------------
       25fy the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK cernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK c
 -------------What i sent was -----------------------
       26DP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating itsontaining an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its
 -------------What i sent was -----------------------
       38ter router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packeter2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet
 -------------What i sent was -----------------------
       39n packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary t containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary t
 -------------What i sent was -----------------------
       40iliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieveasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieve
 -------------What i sent was -----------------------
       41 achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-d at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-
 -------------What i sent was -----------------------
       42our UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem enbased client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem en
 -------------What i sent was -----------------------
       45lety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identitthe problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identit
 -------------What i sent was -----------------------
       46 identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence oy. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence o
 -------------What i sent was -----------------------
       47quence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address routef k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address route
 -------------What i sent was -----------------------
       48ss router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-por1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-po
 -------------What i sent was -----------------------
        3IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP 
 -------------What i sent was -----------------------
        4 its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separateaddress the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate
 -------------What i sent was -----------------------
        5separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs t data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs t
 -------------What i sent was -----------------------
        6 needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative posito use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative posit
 -------------What i sent was -----------------------
        7ve positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the neg
 -------------What i sent was -----------------------
        8 the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper functionative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function
 -------------What i sent was -----------------------
        9function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as
 -------------What i sent was -----------------------
       12istributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-ed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-
 -------------What i sent was -----------------------
       13router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is diIP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is di
 -------------What i sent was -----------------------
       25fy the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK cernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK c
 -------------What i sent was -----------------------
       26DP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating itsontaining an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its
 -------------What i sent was -----------------------
       27ting its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirme route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirme
 -------------What i sent was -----------------------
       28confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop routd. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop rout
 -------------What i sent was -----------------------
       29hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perser, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user pers
 -------------What i sent was -----------------------
       30ser perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by ypective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by y
 -------------What i sent was -----------------------
       31red by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments ofour solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of
 -------------What i sent was -----------------------
       34trol studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on thedied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the
 -------------What i sent was -----------------------
       35d on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK
 -------------What i sent was -----------------------
       47quence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address routef k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address route
 -------------What i sent was -----------------------
       48ss router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-por1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-po
 -------------What i sent was -----------------------
       49 data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Mrt-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. M
 -------------What i sent was -----------------------
       50eased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse afteake all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse afte
 -------------What i sent was -----------------------
       51pse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an r it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an 
 -------------What i sent was -----------------------
       52d of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer compephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer comp
 -------------What i sent was -----------------------
       53fer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. letion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. 
 -------------What i sent was -----------------------
       56ongestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its componenn control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its componen
 -------------What i sent was -----------------------
       57ol (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page
 -------------What i sent was -----------------------
       15 to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. rrmine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. r
 -------------What i sent was -----------------------
       36 UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address f to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address f
 -------------What i sent was -----------------------
       37ddress for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router routor overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router rout
 -------------What i sent was -----------------------
       14ge is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to detescarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to dete
 -------------What i sent was -----------------------
       15 to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. rrmine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. r
 -------------What i sent was -----------------------
       36 UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address f to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address f
 -------------What i sent was -----------------------
       37ddress for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router routor overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router rout