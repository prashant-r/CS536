
 -------------- The message sent was-------------------- 
 57299
 -------------- The message sent was-------------------- 
       0|

Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk
 -------------- The message sent was-------------------- 
      10|3 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task
 -------------- The message sent was-------------------- 
      11|. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when struc
 -------------- The message sent was-------------------- 
      21|trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increas
 -------------- The message sent was-------------------- 
      22|es its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client th
 -------------- The message sent was-------------------- 
      32|the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 
 -------------- The message sent was-------------------- 
      33|60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP conges
 -------------- The message sent was-------------------- 
      43|f the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by lin
 -------------- The message sent was-------------------- 
      44|king with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off
 -------------- The message sent was-------------------- 
      54|ication design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two argu
 -------------- The message sent was-------------------- 
      55|ments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top 3 performers, as deemed by design, implementation, and performance will receive 60, 50, and 40 bonus points.

Bonus Problem (30 pts)

Design a "greedy" variant 
 -------------- The message sent was-------------------- 
       1|-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-c-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-cã@
 -------------- The message sent was-------------------- 
       2|ount packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from ount packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from ã@
 -------------- The message sent was-------------------- 
       3|router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after srouter1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after sã@
 -------------- The message sent was-------------------- 
       4|tripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or tripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or ã@
 -------------- The message sent was-------------------- 
       5|using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the leusing a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the leã@
 -------------- The message sent was-------------------- 
       6|gacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of gacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of ã@
 -------------- The message sent was-------------------- 
       7|cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: dcumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: dã@
 -------------- The message sent was-------------------- 
      16| is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending manageme is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending managemeã@
 -------------- The message sent was-------------------- 
      17|nt packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation appnt packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation appã@
 -------------- The message sent was-------------------- 
      18|, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and imp, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and impã@
 -------------- The message sent was-------------------- 
      19|lement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution tlement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution tã@
 -------------- The message sent was-------------------- 
      20|o implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also o implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also ã@
 -------------- The message sent was-------------------- 
      23|at does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the finaat does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the finaã@
 -------------- The message sent was-------------------- 
      24|l destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilegel destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilegeã@
 -------------- The message sent was-------------------- 
      25| to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP ret to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP retã@
 -------------- The message sent was-------------------- 
      26|urns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. Afurns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. Afã@
 -------------- The message sent was-------------------- 
      38|rlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a conrlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a conã@
 -------------- The message sent was-------------------- 
      39|firmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, tfirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, tã@
 -------------- The message sent was-------------------- 
      40|hese auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured thhese auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured thã@
 -------------- The message sent was-------------------- 
      41|roughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdfroughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdfã@
 -------------- The message sent was-------------------- 
      42|. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part o. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part oã@
 -------------- The message sent was-------------------- 
      45|. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to . A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to ã@
 -------------- The message sent was-------------------- 
      46|hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresseshide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addressesã@
 -------------- The message sent was-------------------- 
      47| of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router  of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router ã@
 -------------- The message sent was-------------------- 
      48|IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at porIP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at porã@
 -------------- The message sent was-------------------- 
       3|router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after srouter1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after sã@
 -------------- The message sent was-------------------- 
       4|tripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or tripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or ã@
 -------------- The message sent was-------------------- 
       5|using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the leusing a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the leã@
 -------------- The message sent was-------------------- 
       6|gacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of gacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of ã@
 -------------- The message sent was-------------------- 
       7|cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: dcumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: dã@
 -------------- The message sent was-------------------- 
       8|esign of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a esign of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a ã@
 -------------- The message sent was-------------------- 
       9|wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top wrapper function of the sendto() system call, dropsendto(), that in addition to the arguments of sendto(), takes two additional integer arguments (last two arguments), totalnum and lossnum, that are used to specify packet losses that will be emulated by the server's dropsendto() call. For example, if totalnum = 1000 and lossnum = 1, then dropsendto() will drop 1 in every 1000 packets by incrementing a counter modulo 1000 and omit calling sendto() when the modulo operation yields 0. These are deterministic losses but the TAs will also trigger probabilistic losses during benchmark evaluation of your protocol by linking with a different implementation of dropsendto(). To remove potential performance side effects introduced by NFS (both server and client side), perform disk read()/write() from the local file system /tmp. When testing, focus on two types of scenarios: "small" files (e.g., 32KB or less) and "large" files (e.g., 20MB or greater). Submit the code and write-up in lab6. The top ã@
 -------------- The message sent was-------------------- 
      12|turing distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerkturing distributed computing services.

To achieve overlay network routing, we will build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerkã@
 -------------- The message sent was-------------------- 
      13|-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set--IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-ã@
 -------------- The message sent was-------------------- 
      25| to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP ret to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP retã@
 -------------- The message sent was-------------------- 
      26|urns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. Afurns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. Afã@
 -------------- The message sent was-------------------- 
      27|ter updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until tter updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until tã@
 -------------- The message sent was-------------------- 
      28|hey are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at thhey are confirmed. A temporary routing table entry will become invalid if 30 seconds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at thã@
 -------------- The message sent was-------------------- 
      29|e first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From e first hop router, modify the legacy app so that it uses a specified port number instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From ã@
 -------------- The message sent was-------------------- 
      30|an end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk Ian end user perspective, the user should experience a noticeable reduction in file transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk Iã@
 -------------- The message sent was-------------------- 
      31|/O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to /O incurred by your solution which is an operating system aspect of network application design. Use your operating systems knowledge to incorporate and balance both network protocol and system overhead components. Although performance is our focus, designing a protocol that works correctly (i.e., transports files reliably) and is implemented correctly (a design and its implementation are not one and the same) is a necessity. There is no standard solution to implementing reliable file transport with negative ACK, hence the first part of the problem entails designing your own protocol and explaining why it works correctly in the write-up. In the second part, implement and benchmark your protocol. If your protocol has parameters that you may want to tune (e.g., payload size, window size), clearly specify them in separate headers files.

To affect controlled, repeatable packet losses during benchmarking, use a wrapper function of the sendto() system call, dropsendto(), that in addition to ã@
 -------------- The message sent was-------------------- 
      34|tion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we wtion control studied in class so that someone familiar with TCP congestion control (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page


Another example of overlay network routing is anonymizing sources. A client that does not wish to reveal its location may employ multiple forwarding nodes to hide its identity. Although real-time tracking while a flow is on-going is feasible, multi-hop forwarding increases the effort expended to backtrack the source. Overlay networks allow arbitrary logical network topologies to be embedded in physical network topologies, a form of virtualization that exports customer tailored views of a shared network which can be useful when structuring distributed computing services.

To achieve overlay network routing, we wã@
 -------------- The message sent was-------------------- 
      35|ill build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter rill build on the tunneling implementation of Problem 1, lab4. As in the tunneling server, the overlay network router daemon, overlayrouter, takes a command-line argument

% overlayrouter server-port

where server-port is a well-known port number on which it waits for client requests. A client request is transmitted by running overlaybuild

% overlaybuild dst-IP dst-port routerk-IP ... router2-IP router1-IP

where the command-line arguments specify the final destination's IP address dst-IP and port number dst-port, and the IP addresses of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter rã@
 -------------- The message sent was-------------------- 
      47| of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router  of a sequence of k overlay network routers that a packet should traverse (starting at router1-IP) before being forwarded by the Internet routing system to reach dst-IP. overlaybuild, when executed at a source with IP address src-IP and port number src-port, sends a UDP packet to router router1-IP at port number server-port whose payload has the format

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

As in the tunneling application, overlayrouter returns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router ã@
 -------------- The message sent was-------------------- 
      48|IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at porIP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at porã@
 -------------- The message sent was-------------------- 
      49|t number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up messt number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up messã@
 -------------- The message sent was-------------------- 
      50|age is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 secage is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry is confirmed. router(k-1)-IP, after performing route table look-up, sends a confirmation packet containing

$$router(k-1)-IP$data-port-(k-1)$

to router(k-2)-IP with port number server-port. Eventually a confirmation will arrive at router1-IP at which point the overlay path will have been established. During the set-up phase, consider a routing table entry temporary until confirmation is received. This can be done by adding a flag in the routing table or using a separate data structure (e.g., delta list) for temporary entries until they are confirmed. A temporary routing table entry will become invalid if 30 secã@
 -------------- The message sent was-------------------- 
      51|onds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port numbeonds elapse after it has been created. As noted above, print to stdout routing table updates for verification, and include the IP address of the router doing the printing and its current time stamp. In production code, we would deal with additional issues such as UDP management packets getting lost, sending a notification to src-IP when a path is confirmed, and sending management packets to tear down an overlay path when not needed. For present purposes, these auxiliary tasks will be ignored.

During testing, run overlayrouter on several sslab and borg machines across both labs. Using a single client running on a separate client machine, test that overlay path set-up initiated by overlaybuild works correctly. Use the UDP traffic generation and ping apps from lab4 and lab2 as legacy benchmark apps. As noted in class, since the legacy app needs to use the same port as overlaybuild for correct forwarding at the first hop router, modify the legacy app so that it uses a specified port numbeã@
 -------------- The message sent was-------------------- 
      52|r instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in fir instead of an ephemeral port number. After single client tests, use multiple clients so that each overlay network router manages multiple overlay paths using a single routing table at each overlay router. In the ping app, compare the ping results when a ping server is contacted through an overlay path with when it is directly reached. In the case of the traffic generation app, for packet spacing 1 msec and payload size 1000 bytes, compare the measured throughput achieved at the receiver. Discuss your findings in lab6ans.pdf and place the file in lab6/.

Problem 2 (200 pts)

Design, implement, and benchmark a UDP-based reliable file transfer client/server app that uses negative ACKs to improve upon TCP's throughput performance in low packet loss networks. Even though negative ACKs are used as principal feedback, limited use of cumulative positive ACKs is needed to yield a practical, working protocol. From an end user perspective, the user should experience a noticeable reduction in fiã@
 -------------- The message sent was-------------------- 
      53|le transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network applle transfer completion time by using your app when compared to the TCP-based file transfer app from Problem 1, lab3. For comparison purposes, the client and server follow the same command-line argument and "connection set-up" interaction. Set block size to 1000 bytes. In the case of UDP, this implies that sendto() and recvfrom() of data is in units of 1000 bytes. Devise and implement your own file transfer completion protocol and describe it in lab6ans.pdf. Call your UDP-based client/server app turboclient and turboserver.

Design your own negative ACK method to achieve fast, reliable transport. Describe the protocol in the write-up lab6ans.pdf. In addition to data payload, you will need to insert bookkeeping information in UDP payload such as sequence numbers, type of ACK, etc. Two components significantly impact performance: design of the negative ACK file transfer protocol per se and the amount of disk I/O incurred by your solution which is an operating system aspect of network applã@
 -------------- The message sent was-------------------- 
      56|of TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion controf TCP congestion control, call it TCP-greedy, that aims to exploit the cooperative nature of other TCP flows sharing a bottleneck link to monopolize bandwidth. The basic idea is simple: assuming there are other flows competiting for shared bandwidth, TCP-greedy, upon detecting possible packet loss, will institute a congestion control action (could include backoff) that increases its bandwidth share by exploiting the fact that other TCP flows will back off. A subtlety of the problem is: when other TCP flows have already backed off as much as is possible (crawling along), or TCP-greedy is the only flow traversing the link, then continued aggressiveness will lead to self-congestion, i.e., shooting oneself in the foot. The trick is to know when to be greedy and when not to be. That is, being effectively greedy is not a trivial task. Sketch a design of your TCP-greedy protocol in the framework of the TCP congestion control studied in class so that someone familiar with TCP congestion contrã@
 -------------- The message sent was-------------------- 
      57|ol (its components and variables), without understanding why it does what it does, would be able to implement code changes in a relatively straightforward manner.

Turn-in Instructions

Please follow the same submission instructions as before with lab6 in place of lab5.

Back to the CS 536 web page
 -------------- The message sent was-------------------- 
      15| a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entryã@
 -------------- The message sent was-------------------- 
      36|eturns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designaeturns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designaã@
 -------------- The message sent was-------------------- 
      37|ted IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At oveted IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At oveã@
 -------------- The message sent was-------------------- 
      14|up message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used asup message is discarded. We will assume that a multi-homed device uses a designated IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used asã@
 -------------- The message sent was-------------------- 
      15| a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entry a label to determine where to forward a packet (called label switching). At overlay router router2-IP, the routing table entry will contain (router1-IP, data-port-1) as source label and (router3-IP, data-port-3) as destination label, and vice versa for packets in the reverse direction. The update process is repeated at every intermediate overlay network router until the last hop is reached. routerk-IP knows that it is the last hop by checking that after stripping its IP address the message is 9 bytes ( = |$dst-IP$dst-port$|) long. After updating its route table, further forwarding of the overlay path set-up message is ceased. Make all overlay routers print route table updates to stdout for verification. The last hop routerk-IP confirms that the requested overlay network path has been successfully set up by sending a UDP packet to the previous hop at port server-port with payload

$$routerk-IP$data-port-k$

which signifies to the previous hop router(k-1)-IP that the routing table entryã@
 -------------- The message sent was-------------------- 
      36|eturns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designaeturns a UDP ACK to overlaybuild which contains a port number, data-port-1, to be used for actual data traffic from src-IP. overlaybuild prints data-port-1 to stdout so that it can be used by a UDP-based legacy app in its command-line argument. For example, in the case of the traffic generation app traffic_snd, we have

% traffic_snd router1-ip data-port-1 payload-size packet-count packet-spacing

As in the tunneling app, since we don't have root privilege to modify the kernel to enable full transparency, the first-hop overlay router IP address router1-ip is specified in place of dst-IP in the command-line argument of the legacy app.

overlayrouter running at router1-IP, after receiving the client request

$dst-IP$dst-port$routerk-IP$...$router2-IP$router1-IP$

returns a UDP ACK with data-port-1 if the last IP address inscribed in the message matches its own IP-address. If there is a mismatch, the path set-up message is discarded. We will assume that a multi-homed device uses a designaã@
 -------------- The message sent was-------------------- 
      37|ted IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At oveted IP address for overlay network routing purposes. After a match, router1-IP proceeds by contacting the next-hop overlay network rourter router2-IP at port number server-port to set up the remaining overlay path. Before doing so, it strips its own IP address from the received message and forwards

$dst-IP$dst-port$routerk-IP$...$router2-IP$

to router2-IP at server-port from router1-IP with port number data-port-1. overlayrouter running at router2-IP returns a UDP ACK containing an unused port number data-port-2 to router1-IP at port number data-port-1. overlayrouter running at router1-IP maintains a routing table which specifies that UDP packets arriving from (src-IP, src-port) should be forwarded to (router2-IP, data-port-2). The table also specifies that a UDP packet arriving from (router2-IP, data-port-2) should be forwarded to (src-IP, src-port). Thus the sender IP address/port number pair is used as a label to determine where to forward a packet (called label switching). At oveã@